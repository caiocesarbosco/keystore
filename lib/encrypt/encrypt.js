const constants = require('./enums.js');
const utils = require('../utils/utils.js');
const { subtle } = require('crypto').webcrypto;
const config = require('../config/config.js');
const configFile = require('../../config.json');
const crypto = subtle;
const settings = new config.Config(configFile["encryptor"]);

/**
 * Symmetric Encryption Algorithm used for Encrypt Keyrings 
 * inside Local Storage. It's set by config.json file under 'encryptor/encrypt_algoritm'
 * key. See SYMMETRIC_ENCRYPT_ALGORITHM enum on enums.js to see supported encryption algorithms.
 */
const encrypt_algorithm = settings.getParameter('encrypt_algoritm');

/**
 * Symmetric Sign Algorithm used for Signing Encrypted Keyrings 
 * inside Local Storage. It's set by config.json file under 'encryptor/sign_algorithm'
 * key. See SIGN_ALGORITHM enum on enums.js to see supported signing algorithms.
 */
const sign_algorithm = settings.getParameter('sign_algorithm');

/**
 * Hash Algorithm used for signature algorithm Keyrings. It's set by config.json file under 'encryptor/hash_algorithm'
 * key. See HASH_ALGORITHM enum on enums.js to see supported hash algorithms.
 */
const hash_algorithm = settings.getParameter('hash_algorithm');

/**
 * Derive Key Algorithm used for Deriving a Key from User's Password. It's set by config.json file under 'encryptor/derive_key_algorithm'
 * key. See DERIVE_KEY_ALGORITHM enum on enums.js to see supported derive key algorithms.
 */
const derive_key_algorithm = settings.getParameter('derive_key_algorithm');

/**
 * Number of iterations Parameter for Derive Key Algorithm. It's set by config.json file under 'encryptor/iterations'
 * key. See ITERATIONS enum on enums.js to see iterations options.
 * @constant
 */
const iterations = settings.getParameter('iterations');

/**
 * Derive Key's Size. It's set by config.json file under 'encryptor/derive_key_size'
 * key. See KEYSIZE enum on enums.js to see keysize options.
 */
const derived_key_size = settings.getParameter('derived_key_size');

/**
 * Verifies comparing Data's Signature with Signed Data using Derived Key by User's Password
 * Sign's Algorithm can be choosed at config.json file.
 * @param {String} password User's Password 
 * @param {Array} signData Data Signed by signKeyPairFile function 
 * @param {String} data Raw Data (without signature)
 * @returns {boolean} returns true if signature is right. Otherwise it must return false.
 * @function
 * @async
 */
async function verifyHmac(password, signData, data) {

  let derivedKey = await deriveKey(password);
  let isValid = await crypto.verify({name: sign_algorithm}, derivedKey.sign, signData, data);
  return isValid;
}

/**
 * Signs raw data using Derived Key generated by User's Password
 * Sign's Algorithm can be choosed at config.json file.
 * @param {String} data Data to be signed
 * @param {String} password User's Password
 * @returns {Array} returns a buffer containing Signed Data
 * @async
 */
async function signKeyPairFile(data, password) {
  let derivedKey = await deriveKey(password);
  let signed = await crypto.sign({name: sign_algorithm}, derivedKey.sign, data);
  return signed;
}

/**
 * Derive a Key using User's Password as "Root Key".
 * Deriving Key's Algorithm and Parameters (Iterations, Hash Algorithm, Keysize) can be choosed at config.json file.
 * @param {String} password User's Password 
 * @returns {Obj} return a Obj containing two derived keys: one for signature purpose other for encryption.
 * @async
 */
async function deriveKey(password) {

  let salt = utils.asciiToUint8Array("MySalt123456789");
  let encoder = new TextEncoder(32);
  let passwordKey = await crypto.importKey("raw", encoder.encode(password), derive_key_algorithm, false, constants.KEY_USAGE.DERIVE);

  var kdfParams = {
      name: derive_key_algorithm,
      salt: salt,
      iterations: iterations,
      hash: hash_algorithm
  };

  var encriptAlgorithm = {name: encrypt_algorithm, length: derived_key_size};
  var signAlgorithm = {name: sign_algorithm, hash: hash_algorithm, length: derived_key_size};

  var signDerivedKey = await crypto.deriveKey(kdfParams, passwordKey, signAlgorithm, true, constants.KEY_USAGE.SIGN_VERIFY);
  var encryptDerivedKey = await crypto.deriveKey(kdfParams, passwordKey, encriptAlgorithm, true, constants.KEY_USAGE.ENCRYPT_DECRYPT);

  var derivedKey = {
      sign: signDerivedKey,
      encrypt: encryptDerivedKey
  }
  return derivedKey;
}

/**
 * Encrypts raw data using derived key generated by User's Password.
 * encrypt_alorithm can be choosed by config.json file.
 * @param {String} data Data to be encrypted
 * @param {String} password User's Password
 * @returns {Array} returns a buffer containing encrypted data
 * @async
 */
async function encryptsKeyPairFile(data, password) {
 
  var iv = utils.asciiToUint8Array("AnyRandomData012");
  var derivedKey = await deriveKey(password);
  var cipher = await crypto.encrypt({name: encrypt_algorithm, counter: iv, length: 32}, derivedKey.encrypt, utils.asciiToUint8Array(data));
  return cipher;
}

/**
 * Decrypts encrypted data using derived key generated by User's Password.
 * decrypt_alorithm can be choosed by config.json file.
 * @param {Array} data Data to be decrypted
 * @param {String} password User's Password
 * @returns {String} returns decrypted data as a string.
 * @async
 */
async function decryptsKeyPairFile(data, password) {
 
  var iv = utils.asciiToUint8Array("AnyRandomData012");
  var derivedKey = await deriveKey(password);
  var plainText = await crypto.decrypt({name: encrypt_algorithm, counter: iv, length: 32}, derivedKey.encrypt, data);
  return utils.bytesToASCIIString(plainText);
}

/*
async function storingEncryptedUserKeyPairs(data, user, password) {

  var derivedKeys = await deriveKey(password);
  var encryptedData = await encryptsKeyPairFile(utils.asciiToUint8Array(JSON.stringify(data)), derivedKeys.encrypt, password);
  var signedData = await signKeyPairFile(encryptedData, derivedKeys.sign);
  var jsonEncriptedUserKeyPair = {
      "user": user,
      "encrypted": utils.bytesToHexString(encryptedData),
      "signed": utils.bytesToHexString(signedData)
  }
  appendUserKeyStore(jsonEncriptedUserKeyPair); 

}

async function decryptUserKeyPairs(user, password) {
  var encriptedUserKeyPairObj = getUserKeyRing(user);
  var derivedKeys = await deriveKey(password);
  var plainObj = await decryptsKeyPairFile(utils.hexStringToUint8Array(encriptedUserKeyPairObj.encrypted), derivedKeys.encrypt);
  var plainText = utils.bytesToASCIIString(plainObj);
  return plainText;
}

async function checkEncryptedUserKeyPair(user, password) {

  var derivedKeys = await deriveKey(password);

  var encriptedUserKeyPair = getUserKeyRing(user);

  var isVerified = await verifyHmac(derivedKeys.sign, utils.hexStringToUint8Array(encriptedUserKeyPair.signed), utils.hexStringToUint8Array(encriptedUserKeyPair.encrypted));

  return isVerified;

}*/

module.exports = {
  deriveKey: deriveKey,
  encryptsKeyPairFile: encryptsKeyPairFile,
  decryptsKeyPairFile: decryptsKeyPairFile,
  verifyHmac: verifyHmac,
  signKeyPairFile: signKeyPairFile
};